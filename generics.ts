// Описать функцию словами, рассказать для чего в ней нужны дженерики

// 1) функция

// function identity<T>(arg: T): T


// Допустим у нас есть функция identity. Мы хотели бы, чтобы эта функция работала не только со значениями типа Number,
// но и срабатывала для любого типа. Именно в этом нам помогут дженерики. Они позволяют функции принимать значения
// любого типа данных на входе и, в зависимости от них, преобразовывать саму функцию.
function identity<Number>(value: Number): Number {
    return value;
}

function identity2<T>(value: T): T {
    return value;
}

console.log(identity2<String>('Hello')) // Hello
// При вызове функции, вместо <T> передаётся переданный тип
// Будет это выглядеть так:
// function identity2<String>(value: String): String {
//     return value;
// }


// 2) функция
// class GenericNumber<T> {
//     zeroValue: T;
//     add: (x: T, y: T) => T;
// }
//
// let myGenericNumber = new GenericNumber<number>();

// С классами и интерфейсами они работают точно таким же образом. В этом случае указание типов следует после имени интерфейса или класса.
// Дженерики позволяют нам создавать повторно используемые компоненты, работающие с различными типами передаваемых им данных.

// В противном случае нам бы пришлось указывать все возможные типы или использовать any, но при использовании any
// функция принимает аргумент какого-то типа и возвращает значение какого-то типа, но при этом они никак не связаны.
// Грубо говоря, мы можем передать аргумент типа number и получить значение типа string – это валидно, потому что any подразумевает под собой всё что угодно.
